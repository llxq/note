-> vue.js
	-> vue.js是一套构建用户界面的框架，只关注视图层，它不仅易于上手，还便于与第三方库或既有项目整合，(vue有配套的第三方库，可以整合起来做大项目的开发，vue语法也是可以用于进行手机APP开发的，需要借助于 weex)
	
	-> 在 vue 中，一个核心的概念，就是让用户不在操作DOM元素，解放了用户的双手，让我们可以有更多的时间去关心业务逻辑
	
	-> 框架：是一套完整的技术解决方案，对项目的侵入性较大，项目如果需要更换框架，则需要重新架构整个项目

	-> 库(插件)：提供某一个小功能，对项目的入侵性较小，如果某个库无法完成某些需求，可以很容易切换到其他库来实现需求


	-> MVVM
		-> MVVM
			-> M：Model   业务逻辑和数据库
			-> V：view	  页面视图
			-> VM：ViewModel	视图数据模型和展现逻辑
		-> V：Vue实例所控制的这个元素区域，就是我们的 V 
		-> VM：我们 new 出来的这个 Vue 对象，就是我们 MVVM 中的 VM
		-> M：data 就是 MVVM 中的 M，专门用来保存每个页面的数据

	-> 基本语法
		-> 引入vue.js  
		-> 定义一个区域
			-> 区域中使用 vue 定义的数据  {{ msg }}
		-> 写 vue 脚本
			-> var vn = new Vue({
				el: '这里填写需要操纵的 HTML 元素区域',
				data: {	 // 这个 data 就是控制 el 需要使用到的数据
					msg：'这里就是填写需要发送的数据'   // 名称随意
				},
				methods: {
					 // 这个 methods 中定义了当前 Vue 中所需要的所有方法
				}
			})

	-> vue对象中，会自动监听当前 data 数据发生的变化，并且自动修改，并且同步到页面上
  -> 可以让我们不需要关心页面数据的变化，减少了对 dom 的操作
	-> 在当前对象中，需要使用 this 调用当前中的数据
	-> 修改 当前 this.属性 的值可以修改当前对象中对应属性的值


	-> 如果想要在 vue 实例中获取 data 中的数据，使用 this.属性名 调用，并且如果修改了会同步到 data 中
		-> vue实例会自动监听自己身上 data 数据的变化，只要数据发生变化，就会同步到页面中去，(好处：只需要操作数据即可，不需要关心页面的重新渲染)
	-> 调用方法名也是  this.方法名()
	-> this 指代的就是 vue 实例的对象

	-> 指令
		-> v-cloak
			-> 使用 v-cloak 能够解决 差值表达式闪烁问题
			-> 添加一个样式，[v-cloak] {display:none}	将它隐藏即可
		->{{ msg }}
			-> 插件表达式可以在前后放置任意元素和字符，只会替换当前占位符，不会把整个元素替换
			-> 不能将HTML字符串解析为HTML
		
		-> v-text="msg"
			-> 效果与 差值表达式 一样，也能将数据渲染给指定元素
			-> 默认 V-text 是没有闪烁问题的
			-> v-text会覆盖元素中原本的内容，全部替换为指定的值
			-> 不能将 HTML字符串 解析为 HTML

		-> v-html
			-> 可以将 HTML字符串 解析为 HTML
			-> 也会覆盖当前元素中的内容

		-> v-bind
			-> v-bind:属性="值"
				-> v-bind:title="myTitle"
			-> v-bind: 是Vue中提供的用于绑定属性的指令
			-> 在 v-bind 中可以把 "" 里面的内容当做为一个变量，可以使用 + 为变量添加字符
			-> 也就是说 v-bind指令会把 等号后面的(也就是 "") 的值当做是一个变量去解析，会被认为是一个表达式，里面可以填写 js 表达式
				-> v-bind:title="myTitle+'添加新的东西'"
			-> 注意：v-bind: 可以简写为 :要绑定的属性
			-> v-bind：中，可以写一些合法的js表达式

		-> v-on
			-> vue 中提供了 v-on事件绑定机制
			-> v-on：事件名="methods中定义的方法名"
				-> 等号后面只能写 methods 中定义的方法
			-> v-on的缩写：@
				-> @click="fun"
					-> 没有参数就不用加 () 


-> 事件修饰符
	-> .stop：阻止冒泡
		-> @click.stop="事件名"
		-> 阻止全部元素冒泡，不会再向上继续冒泡
	-> .prevent：阻止默认事件
		-> @click.prevent="事件名"
	-> .capture：添加时间侦听器时使用事件捕获模式
		-> @click.capture="事件名"
		-> 事件默认是冒泡执行的，该修饰符可以让时间在 捕获阶段触发，也就是从外到里执行事件
	-> .self：只当事件在该元素本身(比不不是子元素)触发时触发回调
		-> @click.self="事件名"
		-> 只有通过该元素本身自己触发才执行该事件，如果是通过子元素冒泡或者捕获阶段触发的的则不触发该事件
		-> 只阻止当前元素触发冒泡，并不会真正的阻止冒泡，还会继续向上冒泡
	-> .once：事件只触发一次
		-> 使用 .once 只触发一次该事件，在此点击则不会触发该事件了

-> 按键修饰符
	-> .enter：键盘修饰符
		-> @keyup.enter=""
			-> 当 按下 enter的时候触发该方法
	-> .tab
	-> .delete (捕获 删除 和 退格 键)
	-> .esc
	-> .space
	-> .up
	-> .down
	-> .left
	-> .right
	-> 也可以直接使用 键盘对应的 编码 来响应
		-> @keyup.112 = ''		
			-> 当 按下 112 对应的键 (F12) 时触发该方法

	-> 事件修饰符是可以串连的
		-> @click.stop.prevent.self.once="事件名"


-> v-model指令 和 双向数据绑定
	-> 双向数据绑定只能适用于 表单元素
	-> 使用方法：v-model="需要绑定的属性"
		-> <input type="text" v-model="msg" >
			-> v-model也可以实现数据绑定
			-> 当 input 的值修改的时候，msg的值也会照样修改，实时改变
			-> 实现了表单元素与 model 中数据的双向绑定

-> 在 vue 中使用样式
	-> 使用 class 样式，需要在 el 所属控制区域之内
		-> 数组
			-> :class="['类名1', '类名2', .....]"
		-> 数组中使用 三元表达式
			-> 在 data 中定义一个变量，比如 flag: true
			-> 然后在 数组中使用三元表达式
				-> class="['类名1', flag ? '类名':'']"
					-> 如果 flag 为 true，则添加该类名，否则为 '' (空)
		-> 数组中嵌套对象
			-> class="['类名1', {'类名': flag}]"
				-> 如果 flag 为 true，则添加该类名，否则不添加
		-> 直接使用对象
			-> class="{'类名': true/false}"		// 类名 可以不加 ''	
				-> true 代表的是应用该类，false 代表不使用该类。
				-> 使用方法与 ng-class 一样

	-> 使用内联样式
		-> 直接在元素上通过 :style 的形式，书写样式对象
			-> <span :style="{color: red,'font-weight': '200em'}"></span>
		-> 将样式对象定义到 data 中，并直接引用到 :style 中
			-> 直接在 data 中定义 style的值 {color: red,'font-weight': '200em'}
			-> 然后在需要应用的元素上   :style:'data中定义的值'
		-> 在 :style 中，通过数组，引用多个 data 上的样式对象
			-> 在 data 中定义多个 对象，
			-> 在 元素中使用 :style="[对象1，对象2]"

-> v-for指令 和 key 属性
	-> 迭代数组
		-> v-for="(value, index) in 遍历对象"
	-> 迭代对象中的属性
		-> v-for="(value, key, index) in 遍历的对象"
			-> value 就是对象的值，key 就是对象的 key，index 就是索引
	-> 迭代数字
		-> v-for="const in 一个数字"
			-> const 的值是从 1 开始的
			-> v-for="const in 10"

	-> 在 vue 2.2.0+ 的版本，当 在组件中使用 v-for 时，key属性 是必须在的
		-> 每次 for 循环的时候通过指定 key 来标识当前循环这一项的唯一身份
		-> :key="value"
			-> 注意：v-for 循环的时候，key 属性只能使用 number 或者 string
			-> 注意：key 在使用的时候必须使用 v-bidn绑定  :key 
		-> 使用 key 可以将data中的数据与页面上的数据关联起来
		-> 保证其唯一性


-> v-if 与 v-show
	-> v-if：移除或者重新生成当前元素 移除的时候变成了一个 注释 <!---->
		-> 有较高的切换性能消耗
		-> 如果元素涉及到频繁的切换，最好不要使用 v-if
		-> 如果元素可能永远不会显示出来，则推荐使用 v-if
	-> v-show：不会移除元素，只是将元素的 display 变为了 none
		-> 有较高的初始渲染消耗
		-> 如果一个元素可能被创建之后永远没有被显示的话，会有较高的初始渲染消耗
