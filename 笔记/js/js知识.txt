！！！！！！！！！！！
	about:blank
！！！！！！！！！！！ 

-> js中没有真正的多线程

-> every() 方法用于检测数组所有元素是否都符合指定条件（通过函数提供）。

-> some() 方法用于检测数组中的元素是否满足指定条件（函数提供）。
	-> some() 方法会依次执行数组的每个元素：
		-> 如果有一个元素满足条件，则表达式返回true , 剩余的元素不会再执行检测。
		-> 如果没有满足条件的元素，则返回false。
		
-> every() 方法用于检测数组所有元素是否都符合指定条件（通过函数提供）。
	-> every() 方法使用指定函数检测数组中的所有元素：
		-> 如果数组中检测到有一个元素不满足，则整个表达式返回 false ，且剩余的元素不会再进行检测。
		-> 如果所有元素都满足条件，则返回 true

-> Array.includes 方法   返回一个bool值，判断是否包含指定数据
	-> obj.includes(objStr);		//填写需要检测的字符串
	
-> Array.reduce(function(a,b){  
		return  a+b			// 这个就是返回 当前数组所有数相加的结果
	})
		
-> JSON.stringify(value[, replacer [, space]])
	-> value
		-> 将要序列化成 一个JSON 字符串的值。
	-> replace  可选
		-> 如果该参数是一个函数，则在序列化过程中，被序列化的值的每个属性都会经过该函数的转换和处理；如果该参数是一个数组，则只有包含在这个数组中的属性名才会被序列化到最终的 JSON 字符串中；如果该参数为null或者未提供，则对象所有的属性都会被序列化
	-> space 	可选
		-> 指定缩进用的空白字符串，用于美化输出（pretty-print）；如果参数是个数字，它代表有多少的空格；上限为10。该值若小于1，则意味着没有空格；如果该参数为字符串(字符串的前十个字母)，该字符串将被作为空格；如果该参数没有提供（或者为null）将没有空格。
		
-> JSON.parse("字符串数组")
	-> 将制定的字符串数组 转换为 JSON 对象
	
Array.prototype.slice.call(arguments)能将具有length属性的对象转成数组

-> JavaScript的特点：
	-> 代码可使用任何文本编辑工具编写,语法类似于c和Java
	-> 无需编译,由JavaScript引擎解释执行
	-> 弱类型语言
	-> 基于对象
	-> JavaScript的用途：
		-> 客户端js
			-> 客户端数据计算
			-> 表单输入验证
			-> 浏览器事件的触发和处理
			-> 网页特殊显示效果制作
			-> 服务器的异步数据提交
		-> 服务端js
			-> 分布式运算
			-> 实时服务端
			-> 窗口应用
			-> 网络应用
-> 浏览器内核：
	-> 浏览器内核负责页面内容的渲染,主要由两部分构成：
		-> 1.内容排版引擎  -> 解析HTML/css
		-> 2.脚本解释引擎  -> 解析JavaScript
-> 打开一个空白网页地址：about:blank;

-> 引入js脚本：
	-> <script src="路径"></script>
-> 引入css文件
	-> <link rel="stylesheet" href="路径" type="text/css" />
	
-> JavaScript调试：

-> 常量：const 常量名=值    	//一般常量名要大写

-> 1角度=π/180弧度;

-> 数字所占空间和数值大小无关,所有的数字都占8字节

-> 变量.toFixed(2)   //将当前变量按两位小数输出
	-> 括号中可以填写任何大于零小于20的数
	-> 返回值为字符串类型

-> 变量.charCodeAt(0);  //表示当前变量在Unicode中的唯一编号 这个编号不会改变的
	-> 英文字母、标点：1字节
	-> 每个汉字：2个字节
	
-> 变量类型：
	-> 原始类型：值保存在变量本地的数据类型
		-> 五种：Number、String、Boolean、undefined、null
			-> Number：8bytes 舍入误差->四舍五入
			-> string：一旦创建内容不可改变
					   每个英文字符 1bytes-> 
					   每个汉字字符 2bytes
	-> 引用类型：值不保存在变量本地的数据类型
	
-> 数据类型转换：
	-> 隐式转换：
		-> 特例：在+运算中,如果有一方是字符串类型,那么两个数据都会转换为字符串类型,
			进行字符串的拼接;
		-> 任意类型装换为Boolean：
			-> 只有五个值会被装换为false其他值都会转换为true
				-> ""、NaN、undefined、null、0  ：只有这五个会被转换为false
			-> !!变量    这个!!的作用是把该元素转换为Boolean类型
	-> number("")  他会将空字符串转换为0
	-> undefined==null  是成立的
	
-> 逻辑运算：
	-> 在js逻辑运算中：
		-> ""、NaN、undefined、null、0  ：只有这五个会被转换为false
	-> &&：如果左边为true则返回最后一个的值
		   如果第一个转换为Boolean后不是true,则返回第一个隐式转换为false的值
	-> ||：如果左边返回true则返回true,后面的则短路
		   如果都为false,一直到最后一个false,返回最后一个false
	-> 一般返回结果使用逻辑运算符的短路来执行,因为如果前面条件成立即不会执行后面的
	
-> 短路逻辑：(如果操作简单的情况下,就可以考虑使用短路逻辑)
	-> 条件&&操作：1件事,满足条件就做,否则就不做
		-> 只限于操作简单的情况下
	-> 值1||值2：如果值1有效,就返回值1,否则返回值2
	
-> 三目运算符：多个值,按条件判断,多选一
	
	
-> 变量作用域：一个变量的可用范围
	-> js中的两种作用域：
		-> 全局作用域：一个变量可以在程序的任何位置被访问
		-> 函数作用域：一个变量仅能在函数调用时,内部被访问
-> js中两种变量：
	-> 全局变量：定义在全局作用域的变量
		-> 两种：
			-> 直接在任何函数外声明的变量,全局变量都属于window  全局对象
			-> 无论在任何位置,为从未声明过的变量赋值的时,自动在全局创建同名全局变量
	-> 局部变量：定义在函数作用域的变量
		-> 两种：
			-> 在函数定义内部声明的变量
			-> 参数变量天生就是局部变量

-> 函数其实就是引用类型的对象,函数名其实就是指向函数对象的变量

-> 函数的声明提前：
	->声明提前： 在程序执行前或函数被调用前,将var声明的变量和function声明的函数提前到当前作用域的顶部集中创建
	-> 强调：仅声明提前,赋值留在原地
	-> 会先把声明好的函数放置在最前面(预处理),然后依次向下执行  
	
-> 按值传递：(原始类型)
	-> js中无论变量间赋值或使用变量传递参数时,都是将变量中的值,复制一个副本给对方

-> 全局函数：
	-> 什么是全局函数:ES标准中已经定义好的,开发者可直接调用的函数
		-> isNaN(num)   parseInt/Float(str)....
	-> 编码/解码：
		-> 编码：将URL中的非法字符,改为合法字符表示
			-> 编码成为 utf-8编码格式      一个汉字占3个字节,一个字母或者数字占1个
		-> 解码：将URL中的非法字符编码后的内容,恢复成原文
	-> eval(str)：计算字符串格式的表达式的值,或执行字符串格式的js语句
	-> isFinite()：检查当前数据在不在有限范围内
-> Infinity：无穷大    比如说4/0  这个在js中输出的就是无穷大  也就是Infinity

-> switch case结构：都是根据不同的条件执行不同的代码段,用switch中的表达式的值和case
中的值做 全等 比较
	-> 判断条件是全等比较的时候,首选switch case
	-> 除全等比较外,希望灵活使用条件的时候,使用else if
	
-> 在任意min-max之间取随机整数的公式
	-> parseINT(Math.radom()*(max-min+1)+min) 
	
-> js中没有块作用域：分支/循环结构中声明的变量,出了结构,照样使用
   -> 只有全局作用域和局部作用域

-> 在js中：只要不是声明在函数内部的变量,就是全局变量

-> 1e+157  代表的是 10的157次方  	
	-> e是代表的是科学计数法的意思,
	-> +几是代表10的几次方
	
-> 死循环  for(;;){}

-> for语句里面的变量不一定是一个  (每个变量之间使用逗号隔开	)
	-> for(var i=1,j=6;i<=6;i+=2,j-=2)  
		输出结果是 i=1 j=6 	 i=3  j=4  .....
		
-> 正三角：
	for(var i=1;i<10;i++){
		for(var j=0,arr=[];j<i;arr[arr.length]="*",j++);
		console.log(arr.join(""));
	}
-> 反三角：
	for(var i=1;i<10;i++){
		for(var j=0,arr=[];j<10;j++){
			arr[arr.length]=j<(10-i)?" ":"*";
		}
		console.log(arr.join(""));
	}
-> 等腰三角：
	for(var i=1;i<10;i++){
		for(var j=0,arr=[];j<(10+i-1);j++){
			arr[arr.length]=j<(10-i)?" ":"*";
		}
		console.log(arr.join(""));
	}
-> 乘法口诀表：
	for(var i=1;i<10;i++){
		for(var j=1,arr=[];j<=i;j++){
			arr[arr.length]=[i,"x",j,"=",j*i,(j*i<10?"  ":" ")].join("");
		}
		console.log(arr.join(""));
	}
		
-> null:
	-> null专门表示一个变量不再指向任何对象地址。
	-> null与undefined：
		-> 共同点：都是原始类型,保存在栈中变量本地
		-> 不同点：
			-> undefined：表示变量声明过但未被赋过值。是所有未赋值变量的默认值,一般
				不主动使用
			-> null：表示一个变量将来可能指向一个对象,但目前暂时什么都没指向。一般用
				于主动释放指向对象的引用
		-> 何时使用null：当使用完一个较大的对象时,主动释放对象总是好的习惯

-> js数组越界不会报错！！如果你要赋值的索引并不存在,js会自动生成指定下标元素
-> 从不存在位置取值,也不会报错！！ 会自动返回undefined,但是不会增加新元素

-> 赋值表达式是等号右边的值
	-> while((input=propmt("请输入员工姓名"))!="exit")  
		//这个表达式就是说把Propmt接收到的值赋值给input并且和exit比较

-> 数组.length-1代表的是最后一个元素
-> 数组.length=值：我们可以使用这个来为数组末尾添加元素
-> 改小length可以删除末尾元素

-> 关联数组：可以自己定义下标名称的数组
	-> var 数组名=[];  //定义一个数组
	-> 数组名["自定义下标名"]="值"  //这个就是自定义下标的数组
	-> 如何访问关联数组中的元素  //与普通数组的访问方式是一样的  只是下标变为了自定
									义的下标了
-> 索引数组：自动生成下标的数组都是索引数组

-> 关联数组：哈希(hash)数组：下标是不能重复的
	-> 优势：利用哈希(hash)算法,精确定位某个下标的位置,不需要遍历
-> 索引数组：缺点：下标自动分配,无意义。想要按内容查找元素,只能从头开始遍历

-> API：应用程序接口
	-> 已经实现的,现成的对象和方法。-----提高开发效率
	
-> 	判断一个对象是否是数组：Array.isArray(变量)		//返回true或者false  ie8没有！！
	
-> 数组API：(连接数组)
	-> 数组.toString()    //自动,逗号分隔  将数组内容以逗号分隔
	-> 数组.join("连接符")  //自定义连接符   将数组中的内容以自定义符号分隔
		-> 如果什么都不写,则默认为逗号分隔,如果想要无缝连接,在括号里面加""即可
-> 优化：问题：频繁字符串连接,造成内存浪费
	-> 	解决方法：先将要拼接的字符串放入到数组中,最后 arr.join();
	-> var arr=["a"]	 arr[arr.length]="b" 	对象没有浪费,一直都是只有arr一个对象
-> 拼接和截取：不修改原对象(原对象保持不变),返回新对象
	-> var newArr=arr.concat(新值1,新数组,新值2....)   //拼接
	-> var subArr=arr.slice(开始位置,结束位置)  //结束位置可省略,表示截取到最后、
		-> 截取的位置不包括结束位置那个字符,含头不含尾
		-> 两个参数都可以取负值,取值为负值,含头不含尾；
			-> 可以正负混搭
			-> 负数是从-1开始的
	-> var.split()   字符串的分割,也可以分割数组
-> arr.splice：删除,插入,替换
-> arr.reverse()：排序  只负责将原数组颠倒

-> arr.sort()：数组排序
	-> 问题：sort方法是默认将一个数组转换为字符串升序排序
	-> 如何自定义sort方法的排序？
		-> arr.sort(比较器方法)
			-> 写一个比价数字的比较器
				-> function compareNum(a,b){return a-b};
				-> 调用 arr.sort(compareNum)
-> 冒泡排序修改判断方法  判断当前元素减去后面的元素是否是大于零
-> 比较器函数：专门比较任意两数大小的函数
	-> 两个特点：有两个参数,分别表示要比较的两值
				 无论比价逻辑是什么,都要返回一个数字

-> 函数对象作为参数：作为参数的时候不需要加括号

-> 冒泡排序：方法
	-> function sortArry(arr,compare){
		for(var i=0;i<arr.length-1;i++){
			for(var j=0;j<arr.length-1-i;j++){
				if(compare(arr[j],arr[j+1])>0){
					var tmpe=arr[j];
					arr[j]=arr[j+1];
					arr[j+1]=tmpe;
				}
			}
		}
	}
-> 比较器方法：//sort方法默认是从小到大,如果需要从大到小的话,只需要将比较器返回的结
				果变为相反即可,也就是加个负号即可
	function compareNumAsc(a,b){
		return a-b;   
	}
	function compareNumDesc(a,b){
		return -(a-b);      //b-a
	}
	
-> 栈和队列：js中没有真正的栈和队列的类型
			 一切都是用数组对象模拟的
	-> 栈：只能从一端进出的数组,另一端封闭
			先进的后出
		-> 何时使用：今后只要仅希望数组从另一端进出时
			-> 两种情况：
				-> 末尾出入栈：已入栈元素的下标不在改变
					-> 入栈：arr.push(新值1....)
					-> 出栈：var last=arr.pop();   //会返回最后一个元素
				-> 开头出入栈：每次入栈新元素时,已入栈元素的位置都会向后瞬移
					-> 入栈：arr.unshift(新值1....); //就是说第一个进去的下标是最后
					-> 出栈：var first=arr.shift();  //shift的时候谁在最外边谁下车
	-> 队列：只允许从末尾进入数组,必须从开头出数组
		-> 结尾入队列：arr.push()；
		-> 开头出队列：var first=arr.shift();
		
-> 运用栈十进制转换为二进制方法：  //直接tostring(2).....
	-> 转换为二进制：
		-> function dec2bin(dec){
				var result=[];
				while(dec>0){
					result.unshift(dec%2);
					dec=parseInt(dec/2);
				}
				return result.join("");
			}
	-> 转换为十进制：
		-> function dec10bin(dec){
		}
		
-> 二维数组：数组中的元素,又引用了另一个子数组对象
	-> 何时使用二维数组：只要保存横行竖列的二维数据
						 保存上下级关系的数据时
	-> 如何访问二维数组中的数据：arr[行下标][列下标]
	-> 数组越界问题：列下标可以越界,行下标不可以越界
	
-> 字符串：
	-> 多个字符组成的一个只读集合(数组)
	-> 凡是数组对象中,不修改原对象的API,字符串都能用
	-> 内置对象：
		-> 内置对象就是ECMAScript标准中已经定义好的,由浏览器厂商已经实现的标准对象
		-> 内置对象中封装了专门的数据和操作数据常用的API。
		-> js中内置对象列表:
			-> String,Boolean,Number,Array,Date,RegExp,Math,Error,Functon,Object,
				Global(全局  相当于是window)
	-> 包装类型：
		-> 专门封装原始类型的数据,并提供对原始类型数据常用操作的内置类型(对象)
		-> 为什么要有包装类型？让原始类型的数据也可以像引用类型一样,拥有方法和属性
		-> js中的包装类型有三个：
			-> String、Boolean、Number类型  (boolean类型不能new)
		-> 何时使用包装类型？只要用原始类型的数据调用方法或访问属性时,js属性都会自动
			创建对应的包装类型对象。
			-> 原始类型的数据本来没有任何方法,当程序中使用原始类型调用方法时,程序会
				自动创建包装类型对象来封装该数据
		-> 方法调用完,包装类型对象自动释放
	-> String API:
		-> 转义字符：当字符串的内容和程序的特殊符号冲突时,或字符串中包含功能字符时,
			都用\转化字符的意义
			-> \t 相当于是tab键
		-> 大小写装换：
			-> 都转大写：str.toUpperCase();
			-> 都转小写：str.toLowerCase();
		-> 获取指定位置字符：
			-> str[i]  //拿到任意位置的字符
			-> str.charAt(i)  
			-> str.charCodeAt(i)	//返回字符的Unicode编码
		-> 查找关键字的位置：
			-> var i=str.indexOf("keyWord",开始位置);  //开始位置省略的话从0开始
				-> 不区分大小写
			-> var i=str.lastIndexOf("keyWord",结束位置) //从指定位置从后向前找
				-> 就是查找最后一次出现的位置   定义了结束位置就查找到结束位置为止
		-> 获取子字符串：
			-> var subStr=str.slice(starti,end+1)   因为不包含最后一个字符
			-> var subStr=str.subString(stati,end+1)  //不支持负数
			-> var subStr=str.substr(starti,取几个)  
		-> 分割字符串：
			-> var arr=str.split("分隔符")  //arr中是以数组形式保存每个字符串
			-> 将字符串切割为字符数组：
				-> var chars=str.split("")  //写空字符串 就是将每个字符都分割开来
					-> 可以使用正则
		-> 连接字符串：
			-> concat(str1,str2....strn) 用于拼接两个或多个字符串
			-> 当然也可以使用"+"		//一般使用加号
		-> 模式匹配：按照规则查找或替换字符串中的子内容
			-> 查找：i和g可以单独使用   i：不区分大小写   g：全部匹配
				-> //只能从开始位置,找第一个匹配的关键字
					-> var i=str.search("keyWord");  
						-> 何时使用：仅判断有没有关键字时
						-> 忽略大小写写法：var i=str.search(/keyWord/i)  不加双引号
						-> indexOf不支持模式匹配
				-> 获得所有关键字的内容：
					-> var arr=str.match(/keyWord/ig);
						-> arr表示了所有匹配的关键字的内容
						-> 如果没有找到则 返回null
						-> match方法只能获得第一个关键字的位置,而且不在数组中
						-> 加了g之后 无法获得关键字的下标位置
			-> 替换：
				-> var newStr=str.replace(模式,替换内容)  //可以写正则
					-> 固定套路：利用replace格式化数据
						"替换值"中,也可以使用$n,和RegExp.$n的用法完全相同
				-> replace 方法的第二个参数可以是一个回调函数，回调函数中有三个参数
					-> 第一个参数是：表示匹配到的字符串
					-> 第二个参数是：表示匹配到的字符串的最小索引位置(RegExp.index)
					-> 第三个参数是：表示被匹配到的字符串


-> 正则表达式：
	-> 匹配API：reg.test("正则字符串","ig"); //验证是否符合要求
	-> 查找API：reg.exec("被查找的字符");  
	//在当前字符中查找所有符合reg规定的关键字的位置
		-> 定义一个arr数组来保存当前关键字的内容和位置
		-> 其中arr[0]:保存了当前关键字的内容
		-> arr[index]保存了当前关键字的位置
		-> reg.lastIndex：保存下次开始查找的位置
		-> 每次查找到一个之后index的值都会发生改变
	-> 何时使用：只要即时查找内容,又查找位置,只能使用reg.exec
		-> RegExp.$n ：取本次匹配结果中第n个()匹配的子内容   n是从1开始的
		-> 只能保存本次的第n个结果
	-> (/2)必须和2中的内容一致
	-> /m代表多行模式multiline，如果目标字符串中不含有换行符\n，即只有一行，那么/m修饰符没有任何意义。
	
-> Math：专门执行数学计算的对象,封装了数学计算中常用的常量
	-> 取整：3种
		-> 上取整：只要超过就取下一个整数
			-> Math.ceil(n);
		-> 下取整：超过当前数取上一个数
			-> Math.floor(n);
		-> 四舍五入取整：
			-> Math.round(n);  //返回值为数字  只能取整
	-> 乘方/开方
		-> 乘方：Math.pow(n,m) //计算n的m次方
		-> 开平方：Math.sqrt(n)   //计算n的平方根
	-> 获取最大值,最小值：(不能存放数组)
		-> Math.max(a,b,c....);
		-> Math.min(a,b,c....);
		-> 固定套路：
			-> Math.max.apply(Math,arr);   相当于是->Math.max(Math,arr[0])
	-> 随机数：Math.random();	0<=n<1	0-n  或者1-n  可以取0或者1取不到n
		-> 任意min到max之间取一个随机整数
			-> parseInt(Math.random()*(max-min+1)+min)
			-> 或者：Math.floor(Math.radom()*(max-min+1)+min);
-> Date：封装了一个时间点,提供了对时间和日期的API
	-> Date中封装了从1970年1月1日0点0分0秒至今的毫秒数
	-> 创建Date对象：4种
		-> var now=new Date();  //创建一个新日期对象同时,保存了当前时间点的毫秒数
			-> 其实就是获得当前客户端的时间
		-> 自定义时间对象:返回的就是自定义的时间
			-> var time=new Date("xxxx/xx/xx[xx:xx:xx]")  //后面的月需要减一
			-> date.getTime();  //获得日期对象中的毫秒数
			-> 两个日期相减会自动调用getTim
		-> date.setxxx(date.getxxx()+/-n);

-> 异常:
	-> js中一旦发生错误,就会自动创建一个Error类型对象
	-> js中有几种错误类型：6种
		-> SyntaxError：语法错误
		-> ReferenceError：引用错误   //找不到变量或对象
		-> TypeError：类型错误  //错误的使用了对象中的方法
		-> RangeError：范围错误  //参数超出范围
		-> EvalError：调用eval函数时出错
		-> URLError：URL错误
	-> 游戏处理：在程序发生错误时,保证程序不退出或正常退出 
	-> 建议：尽量使用优先使用if...else结构判断已经预知的错误只有无法预知的错误,才用
			 try catch。
	-> tryCatch用法之一：解决浏览器兼容性能问题
	-> 抛出自定义异常：throw new Error("自定义错误消息")
	
-> Function对象：
	-> js中一切都是对象   //函数也是对象,函数名其实是引用函数对象的变量
	-> js中不存在重载！
	-> arguments对象：
		-> 无法确定当前函数需要几个参数的时候使用arguments
		-> 函数对象内自动创建的专门接收所有参数值的类数组对象
		-> arguments[i]：获得传入的下标为i的参数值
		-> arguments.length：获得传入的参数的数量
		-> 即使定义了参数变量,arguments对象同样会收到所有参数
	-> 函数对象本质：
		-> 创建函数对象：3种方式
			-> 声明方式：function 函数名(参数){}   //这个是函数名和定义都被提前
				-> 这个可以在任何地方调用
			-> var 函数名=function(参数){}	 //这个是函数名变量声明提前,赋值留在原地
				-> 调用必须在声明之后
			-> 使用new创建函数对象：
				-> var 函数名=new Function("参数变量1","参数变量2"....,"函数体");
		-> 内存中的函数对象：
			-> 创建函数对象时：同时创建2个对象
							    函数对象：函数的定义
								作用域链对象：保存了函数对象可用的变量位置
											  默认第一项指向window对象
			-> 调用函数时：又会创建1个新对象：(如果活动对象中有就不会使用window的)
						   活动对象：专门保存局部变量的对象
						   在作用域链对象中追加指向活动对象的引用
			-> 函数调用后：默认仅释放活动对象
							作用域链中活动对象的引用出栈
				 
-> 匿名函数：定义时,不指定函数名的函数
	-> 何时使用：2大用途
		-> 匿名函数自调：定义完立刻执行,执行完立刻释放
			-> 匿名函数自调,定义在那,就在哪执行,不提前
			-> 何时使用：只有确定函数只执行一次的时候使用！！！
			-> 如何自调：(function(参数){函数体})(参数值);
		-> 匿名函数回调：先将函数作为对象传递给另一个函数
						由另一个函数自主决定在需要时调用
			-> 何时使用：只要将一个函数对象传递给其他方法调用时
			
-> 闭包：就是能够读取其他函数内部变量的函数
	-> 问题：局部变量和全局变量的缺陷
		-> 全局变量：容易全局污染
		-> 局部变量：无法共享,不能长久保存
	-> 需要一个既可以共享,又不会被全局污染  //就是闭包
		-> 解决方法：3步：闭包三特点
			-> 定义外层函数,封装被保护的局部变量
			-> 定义内层函数,执行对外层函数局部变量的操作
			-> 外层函数返回内层函数对象,并且外层函数被调动,结果被保存在全局变量中
		-> 何时使用：
			-> 只要保护局部变量,就要用闭包
			-> 即反复使用局部变量,又避免全局污染,就要用闭包
	-> 判断是否闭包3特点
		-> 嵌套函数
		-> 内层函数一定操作了外层函数的局部变量
		-> 外层函数将内层函数返回到外部,被全局变量保存住
	-> 判断闭包执行结果：
		-> 外层函数被调用几次,就有几个受保护的局部变量副本
		-> 反复调用来自一个闭包的函数被调用几次,受保护的局部变量就变化几次
		
-> 面向对象：(只要见到大括号就是对象)
	-> 创建自定义对象：3种方式
		-> var obj={"属性名1":值1,
					"属性名2":值2,
					"功能名":function (){方法体}};
		-> var obj=new obj();		//创建一个空对象
			-> 给对象加属性：obj.属性名=值1;...function(){this.属性名}
		-> 利用构造函数反复创建相同结构的对象
			-> 构造函数：描述一类对象结构的特殊函数
				-> 2步
					-> 定义构造函数：
						-> function 构造函数名|类型名(属性参数1.....){
							this.属性名=属性参数1
						  //在当前正在创建的对象中创建一个属性名,赋值为属性参数1的值
						    .....
							this.方法名=function(){
								方法体
							}
						}
					-> 利用构造函数创建对象：
						-> var obj=new 构造函数名(属性值1....);
							-> new做了那些事：
								-> 创建了一个空对象：new obj={  }
								-> 利用空对象,调用构造函数
									构造函数在空对象中添加属性和方法
								-> 设置新对象的_proto_指向构造函数的prototype对象
								-> 返回新对象的地址
								
	-> 原型链：由各级对象的_proto_逐级继承形成的关系
	-> 获得任意对象的父级原型对象：Object.GetPrototypeOf(子对象)
		=> 子对象._proto_   (这个东西很多浏览器都被禁用了)
											 
	-> 原型对象：每个函数对象都有一个原型对象
		-> 可以通过    构造函数名.prototype.变量名=值    来添加属性
		-> 所有子对象共享的方法,都应该定义在构造函数的原型对象中。
			-> 避免重复定义方法对象,浪费内存
		-> 所有内置类型的API都是定义在类型.prototype上的		
		
		-> 扩展对象属性：2种扩展：
			-> 扩展自有属性：通过某一个具体子对象添加的属性
			-> 扩展共有属性：通过构造函数.prototype添加的属性
		-> 判断自有属性或共有属性：
			-> 判断自有属性：obj.hasOwnProperty("属性名")
			-> 判断共有属性："属性名" in obj  &&  !obj.hasOwnProperty("属性名")
				-> 在原型关系中包含 且 子对象自己没有
		-> 检查对象的原型：isPrototypeOf()  //就是判断一个对象是否是另一个对象的父辈
			-> 这个是判断的是整个原型链的
			-> isPrototypeOf()方法用于判断一个prototype对象是否存在于另一个对象的原
				形链中,如果是,返回true,否则返回false
		-> typeof(obj)：返回当前对象的类型
			
		-> 继承：
			-> js中一切继承都是用原型对象实现的！！
			-> 原型对象：每个函数对象都有一个原型对象
				 构造函数的原型对象负责保存所有子对象共享的成员！！
				
		-> 删除属性：
			-> delete 对象.属性名     只能删除当前对象自己的属性,无法删除公有属性
		-> 全局对象的声明：3种：
			-> var n=1   	   window.n=1		  	window["n"]=1
			   不能delete	    不能被delete		  能被delete
	
-> Object.setPrototypeOf(要设置的原型对象,该对象的新原型);
该方法设置一个指定的对象的原型 ( 即, 内部[[Prototype]]属性）到另一个对象或  null。
	
-> call和apply
	-> call：在调用方法的一瞬间更换调用方法的对象
	-> fun.call(this,参数1,参数2);	//this就是代表想要指定的上下文,就是想要替换的对
										像！后面的参数是要替换的函数的参数
	-> Object.prototype.toString.call(obj);
	   //简单来说就是调用最原始的toString方法,在调用的瞬间更换为obj
	-> apply：语法和用法和call一致
-> 最原始的toString方法：输出对象的类型
-> 最原始的toString方法：Object.prototype.toString
				
-> instanceof：(实例：一个构造函数创建出的每个具体对象)
	-> 语法：obj instanceof 构造函数名
			 判断obj对象是否被构造函数创建出来的
-> constructor：(构造函数的意思)  //一般存在构造函数的对象中
	-> 原型对象的constructor属性
	-> obj.constructor==构造函数名 //判断当前对象的构造函数名是否等于某个值

-> 判断当前对象是否是数组对象：4种
	-> Array.prototype.isPrototypeOf(obj);
	-> obj instanceof Array
	-> obj.construction==Array
	-> 利用Object原型的toString方法	
		-> Object.prototype.toString.call(obj)=="[Object Array]"
				
	-> 封装：其实就是创建对象
	-> 面向对象：在程序中都是用一个对象来描述现实中具体的东西
		-> 属性：描述一个东西特点的变量。
	-> 什么是对象：封装多个数据的存储空间
	-> 什么是自定义对象：封装现实中一个东西的属性和功能的存储空间
	-> js中一切都是对象！所有对象的底层都是关联数组(hash数组)
	-> 属性：如何访问属性：2种：obj.属性名	 obj.["属性名"]
		-> 访问对象中不存在的属性：不会出错,返回undefined
		-> 强行给不存在属性赋值,不报错！js会自动创建同名属性
	-> 如何判断某个对象是否包含指定成员：3种
		-> obj.hasOwnProperty("成员名")
			-> 如果找到,返回true,否则返回false
		-> "属性名" in 对象
		-> 直接使用obj.属性名作为条件
			-> 如果不包含,返回undefined->false
			-> 如果包含,返回值或function->true
			-> 判断方法是否存在时,可省略
			-> 如果确定属性值一定不是null、0、""、NaN 也可以省略
	-> 方法：如何在方法中,访问当前对象自己
		-> this关键字：运行时,指代正在调用方法的对象
		-> this本质是window下唯一的一个指针,指向当前正在调用的方法
		-> 如何在当前方法内,访问当前对象自己的属性,this.属性名
		-> 在方法内访问当前对象自己的属性,必须使用this.属性名  //唯一的方法
		-> this和定义在哪儿无关！仅和调用时使用的当前对象有关
			-> 如果无主的调用或赋值,默认this都是widow
	-> 多态：同一个对象,在不同情况下,呈现不同的状态   //js几乎不支持多态
	
-> 赋值表达式的结果相当于等号右侧表达式的值  

-> 如果我们遍历的时候需要删除某个元素,为了不影响前面的元素位置,我们应该用反向for循环
	也就是--；