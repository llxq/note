-> 影视频处理：
	-> 视屏处理：
		-> 基本内容：
			-> 使用Flash技术处理HTML页面中的视屏内容
				-> 包含音频、动画、网页游戏等
				-> 特点：
					-> 浏览器原生不支持(IE8浏览器要求安装ActiveX组件)
					-> 性能不好(不能过多的使用)
					-> 智能移动端不支持Flash技术
				-> 目前用于替代Flash技术最好的选择就是 HTML5
					-> 几乎所有浏览器原生都支持<video>元素
					-> html5的性能高
					-> 在智能移动端支持非常好
		-> 如何实现视屏处理：
			-> <video>元素：
				-> 属性：
					-> src属性：引入视屏文件路径
					-> autoplay属性：自动播放视频
					-> controls属性：提供视屏播放的控制面板
						-> 只定义属性名,没有 属性值
					-> loop：表示循环播放
					-> poster：可以表示播放之前显示的图片
					-> width和height：设置显示视屏的宽度和高度
					-> preload：预加载
						-> auto：自动加载	(默认值)
						-> none：不加载
						-> metadata：只加载视频的基本信息(不含视屏)
				->高级内容：
					-> 方法：
						-> play()：播放视屏
						-> pause()：暂停播放
						-> load()：加载视屏
						-> canPlayType()：判断当前浏览器是否支持指定视屏格式
					-> 事件：
						-> play：当视屏被播放的时候被触发
						-> pause：当视屏暂停的时候被触发
						-> ended：当视屏播放完的时候触发
						-> error：当视屏播放错误时被触发
						-> canplay：在不考虑整体情况下,只要能播放就播放
							-> 只要下载了一定的可放帧就会触发这个事件
						-> canplaythrough：考虑整体情况下,只要能播放就播放
							-> 当整个视屏可以播放的时候,就会触发这个事件
						-> progress：表示视屏加载的进度
					-> 属性：所有属性都是用于判断的
						-> paused：判断当前视屏是否暂停(true：暂停 false：播放)
						-> ended：表示判断当前视屏是否播放完毕(true：完毕)
						-> duration：表示当前视屏的时长
						-> currentTime：表示当前视屏的播放位置
				-> video元素：
					-> 与其他元素的定位是相对定位时
					-> 问题：
						-> 当video视屏全屏时,浏览器认为video是最前端的
							-> 图片是有显示的,只是被覆盖了
					-> 想要利用video事件完成广告
						-> BUG：不能全屏
					-> 解决方案：
						-> 利用video元素提供的高级编程自己实现
						-> 使用目前已封装好的video的js库
				
			-> 使用<source />元素
				-> 一个video可以包含多个source,每一个source包含一种视屏格式
				-> <video>支持的视屏格式：
					-> MP4格式：目前比较主流
					-> OGG格式：多用于移动端
					-> WebM格式：目前唯一支持超高清格式
						-> 在HTML页面中支持超高清格式
						-> 由Google公司推出
	-> 音频处理：
		-> <audio>元素
			-> 第一种：只支持一种音频格式：
				-> <audio src="音频文件路径"></audio>
			-> 第二种：同时引入多个音频格式
				-><audio>
					<source src="" />
				  </audio> 
			-> <audio>支持的音频格式：
				-> MP3
				-> OGG
				-> WAV
			-> 属性：
				-> 与video一致
	
-> Canvas(画布)
	-> 基本内容：
		-> 简单来说,HTML5提供的新元素<canvas>
		-> Canvas在HTML页面提供画布的功能
		-> Canvas绘制的图形与HTML无无关的
			-> 无法通过DOM获取绘制的图形
			-> 绘制的图形是不能绑定DOM事件的
		-> 只能使用Canvas提供的API
		-> Canvas用途：
			-> 在HTML页面中绘制图标(例如柱状图、饼状图等)
	-> 效果：类似于<div>元素：
		-> BUG：定义<canvas>元素的宽度和高度
			-> css样式方式：宽高比绘制出来是不对的
				-> 使用style属性设置：有问题
				-> 使用<style>元素：没有问题
			-> 使用属性方式：没有任何问题
	-> 绘制图形：
		-> 获取<canvas>元素
		-> 创建画布对象(根据<canvas>元素)
			-> getContext()方法
				-> 返回值,就是画布对象
				-> 参数：表示创建的是2d效果还是3d效果
			-> 注意：
				-> 参数类型是string类型
				-> 参数必须是"2d"或"3d"(固定写法)
			-> 画布(Canvas)对象
				-> 通过该对象使用canvas提供的API方法
	
	-> 绘制图形：
		-> fillRect(x,y,width,height)：实心矩形
			-> x和y：矩形的左上角坐标值
			-> width：设置矩形的宽度
			-> height：设置矩形的高度
		-> stroKeRect(x,y,width,height)：空心矩形
		-> clearRect(x,y,width,height)
			-> 清除指定区域的矩形
		-> 设置颜色：
			-> fillStyle：设置填充颜色
			-> strokeStyle：设置描边颜色
			-> globalAlpha：设置透明度(0-1)
		-> 设置渐变：
			-> 线型渐变：createLinearGradient(x1,y1,x2,y2)
				-> 具有基准线：起点(x1,y1)和终点(x2,y2)
				-> 通过渐变对象,设置渐变颜色
					-> addColorStop(position,color)方法
						-> position：设置渐变颜色的位置
							-> 该值的范围为：0-1
						-> color：设置渐变的颜色
					-> 设置填充颜色	=  渐变对象   再绘制图形即可 
			-> 扇形(射线)渐变：createRadialGradient()
				-> 具有柱体(锥形)	- 	两个圆面积
				-> 参数
					-> x1和y1：第一个圆的圆心坐标值
					-> r1：第一个圆的半径
					-> x2和y2：第二个圆的圆心坐标值
					-> r2：第二个圆的半径
	-> 绘制文字：
		-> 方法：
			-> fillText(text,x,y)	实心文字
				-> text：绘制的文字内容
				-> x和y：绘制的坐标值
			-> strokeText(text,x,y)	   空心文字
		-> 属性：
			-> font：类似于Css中的font属性	
			-> textAlign：设置文字的水平方向对齐方式
				-> left：左对齐
				-> center：水平居中对齐
				-> right：右对齐
			-> textBaseline：设置文字的垂直方向对齐方式
				-> top：顶部对齐
				-> middle：垂直居中对齐
				-> bottom：底部对齐
				-> hanging：悬挂基线  (就是文字超出基准线一点,文字在下面)
				-> alphabetical：字母基线  (文字在上面)
			-> 注意：
				-> 无论是水平方向还是垂直方向对齐,基准线对齐,并不是必要的属性
	-> 阴影效果：
		-> shadowColor：设置阴影颜色
		-> shadowOffsetX：设置水平方向的阴影
		-> shadowOffsetY：设置垂直方向的阴影
		-> shadowBlur：设置阴影的模糊程度
		
	-> 创建路径
		-> (标识)方法
			-> beginPath()		表示开始创建路劲
			-> closePath()		表示结束创建路劲
		-> 设置方法：
			-> rect(x,y,width,height)	设置矩形形状
			-> arc(x,y,radius,startAngle,endAngle,direction)	设置圆形形状
				-> x和y：设置圆心坐标值
				-> radius：设置圆形的半径
				-> starAngle和EndAngle		设置圆形的起始位置
				-> direction：按照顺时针还是逆时针旋转,默认是false
		-> 绘制方法：
			-> stroke()		绘制轮廓
			-> fill()		绘制填充
		-> 绘制线条(直线、折现、多边形)：
			-> moveTo(x,y)	设置这条线的起点坐标值
			-> lineTo(x,y)	设置这条线的终点坐标值
		-> 设置线条
			-> lineWidth：设置线条的宽度,默认值为1(px)
			-> lineCap：设置线条端点的形状
				-> butt：默认值,平直
				-> round：圆角
				-> square：正方向
			-> lineJoin：设置两条线焦点的形状
				-> miter：默认值,尖角
				-> round：圆角
				-> bevel：斜角
			-> miterLimit：配合lineJoin使用
				-> lineJoin的值必须设置为miter,该属性值设置尖角的延伸范围
	-> Canvas处理图片：
		-> 绘制图片：
			-> drawImage(img,x,y)  //直接绘制即可
				-> img：当前(绘制)加载的图片
				-> x和y：绘制图片的坐标值
			-> drawImage(img,x,y,width,height);
			-> 注意：
				-> 必须得保证图片加载完毕(图片的onload事件)之后,再绘制图片
		-> 平铺图片
			-> createPattern(img,type)	  设置平铺
				-> img：平铺的图片
				-> type：平铺的方式
					-> repeat：平铺
					-> no-repeat：不平铺
					-> repeat-x：水平方向平铺
					-> repeat-y：垂直方向平铺
			-> 还得设置颜色为图像平铺
			-> 绘制图形
			-> 注意：
				-> 必须得保证图片加载完毕(图片的onload事件)之后,再绘制图片
		-> 切割图片：
			-> clip()	切割(使用图形切割)
		-> 画布方法	
			-> scale(x,y)	缩放(缩小或放大)
				-> x：水平方向缩放
				-> y：垂直方向的缩放
				-> 参数的取值：
					-> 如果为1,表示不缩放(原大小)
					-> 如果小于1,表示缩小
					-> 如果大于1,表示放大
			-> translate(x,y)	重新定位(x,y)
				-> x和y：新的坐标值
				-> 这个x和y是相对于上次的值定位
			-> rotate(旋转角度)	  旋转画布
				-> 公式为：degress*Math.PI/180;
		-> 状态方法
			-> save()	保存当前画布属性、状态
			-> restore()	恢复画布属性、状态
			
-> chart.js：提供各种图表	(版本不一样)
	-> 6种图表：
		-> 曲线图
		-> 柱状图
		-> 雷达图
		-> 饼状图
		-> 极地区域图
		-> 环形图